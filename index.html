<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>The Ruby Language Toolkit by chriswailes</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>The Ruby Language Toolkit</h1>
          <h2>Everything you need to build a programming language in Ruby</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/chriswailes/RLTK/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/chriswailes/RLTK/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/chriswailes/RLTK" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a name="welcome-to-the-ruby-language-toolkit" class="anchor" href="#welcome-to-the-ruby-language-toolkit"><span class="octicon octicon-link"></span></a>Welcome to the Ruby Language Toolkit</h1>

<p>RLTK is a collection of classes and methods designed to help programmers work with languages in an easy to use and straightforward manner.  This toolkit provides the following features:</p>

<ul>
<li>Lexer generator</li>
<li>Parser generator</li>
<li>AST node baseclass</li>
<li>Class for representing context free grammars</li>
<li>
<a href="http://llvm.org">Low Level Virtual Machine</a> (LLVM) bindings for code generation</li>
</ul><p>In addition, RLTK includes several ready-made lexers and parsers and a Turing-complete language called Kazoo for use in your code and as examples for how to use the toolkit.</p>

<h2>
<a name="why-use-rltk" class="anchor" href="#why-use-rltk"><span class="octicon octicon-link"></span></a>Why Use RLTK</h2>

<p>Here are some reasons to use RLTK to build your lexers, parsers, and abstract syntax trees, as well as generating LLVM IR and native object files:</p>

<ul>
<li><p><strong>Lexer and Parser Definitions in Ruby</strong> - Many tools require you to write your lexer/parser definitions in their own format, which is then processed and used to generate Ruby code.  RLTK lexers/parsers are written entirely in Ruby and use syntax you are already familiar with.</p></li>
<li><p><strong>Re-entrant Code</strong> - The lexers and parsers generated by RLTK are fully re-entrant.</p></li>
<li><p><strong>Multiple Lexers and Parsers</strong> - You can define as many lexers and parses as you want, and instantiate as many of them as you need.</p></li>
<li><p><strong>Token Positions</strong> - Detailed information about a token's position is available in the parser.</p></li>
<li><p><strong>Feature Rich Lexing and Parsing</strong> - Often, lexer and parser generators will try and force you to do everything their way.  RLTK gives you more flexibility with features such as states and flags for lexers, and argument arrays for parsers.  What's more, these features actually work (I'm looking at you REX).</p></li>
<li><p><strong>LALR(1)/GLR Parsing</strong> - RLTK parsers use the LALR(1)/GLR parsing algorithms, which means you get both speed and the ability to handle <strong>any</strong> context-free grammar.</p></li>
<li><p><strong>Parser Serialization</strong> - RLTK parsers can be serialized and saved after they are generated for faster loading the next time they are required.</p></li>
<li><p><strong>Error Productions</strong> - RLKT parsers can use error productions to recover from, and report on, errors.</p></li>
<li><p><strong>Fast Prototyping</strong> - If you need to change your lexer/parser you don't have to re-run the lexer and parser generation tools, simply make the changes and be on your way.</p></li>
<li><p><strong>Parse Tree Graphs</strong> - RLTK parsers can print parse trees (in the DOT language) of accepted strings.</p></li>
<li><p><strong>LLVM Bindings</strong> - RLTK provides wrappers for most of the C LLVM bindings.</p></li>
<li><p><strong>The Contractor</strong> - LLVM's method of building instructions is a bit cumbersome, and is very imperative in style.  RLTK provides the Contractor class to make things easier.</p></li>
<li><p><strong>Documentation</strong> - We have it!</p></li>
<li><p><strong>I Eat My Own Dog Food</strong> - I'm using RLTK for my own projects so if there is a bug I'll most likely be the first one to know.</p></li>
</ul><h2>
<a name="lexers" class="anchor" href="#lexers"><span class="octicon octicon-link"></span></a>Lexers</h2>

<p>To create your own lexer using RLTK you simply need to subclass the {RLTK::Lexer} class and define the <em>rules</em> that will be used for matching text and generating tokens.  Here we see a simple lexer for a calculator:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">Calculator</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Lexer</span>
  <span class="n">rule</span><span class="p">(</span><span class="sr">/\+/</span><span class="p">)</span> <span class="p">{</span> <span class="ss">:PLS</span> <span class="p">}</span>
  <span class="n">rule</span><span class="p">(</span><span class="sr">/-/</span><span class="p">)</span>  <span class="p">{</span> <span class="ss">:SUB</span> <span class="p">}</span>
  <span class="n">rule</span><span class="p">(</span><span class="sr">/\*/</span><span class="p">)</span> <span class="p">{</span> <span class="ss">:MUL</span> <span class="p">}</span>
  <span class="n">rule</span><span class="p">(</span><span class="sr">/\//</span><span class="p">)</span> <span class="p">{</span> <span class="ss">:DIV</span> <span class="p">}</span>

  <span class="n">rule</span><span class="p">(</span><span class="sr">/\(/</span><span class="p">)</span> <span class="p">{</span> <span class="ss">:LPAREN</span> <span class="p">}</span>
  <span class="n">rule</span><span class="p">(</span><span class="sr">/\)/</span><span class="p">)</span> <span class="p">{</span> <span class="ss">:RPAREN</span> <span class="p">}</span>

  <span class="n">rule</span><span class="p">(</span><span class="sr">/[0-9]+/</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="o">[</span><span class="ss">:NUM</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">to_i</span><span class="o">]</span> <span class="p">}</span>

  <span class="n">rule</span><span class="p">(</span><span class="sr">/\s/</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

<p>The {RLTK::Lexer.rule} method's first argument is the regular expression used for matching text.  The block passed to the function is the action that executes when a substring is matched by the rule.  These blocks must return the <em>type</em> of the token (which must be in ALL CAPS; see the Parsers section), and optionally a <em>value</em>.  In the latter case you must return an array containing the <em>type</em> and <em>value</em>, which you can see an example of in the Calculator lexer shown above.  The values returned by the proc object are used to build a {RLTK::Token} object that includes the <em>type</em> and <em>value</em> information, as well as information about the line number the token was found on, the offset from the beginning of the line to the start of the token, and the length of the token's text.  If the <em>type</em> value returned by the proc is <code>nil</code> the input is discarded and no token is produced.</p>

<p>The {RLTK::Lexer} class provides both {RLTK::Lexer.lex} and {RLTK::Lexer.lex_file}.  The {RLTK::Lexer.lex} method takes a string as its argument and returns an array of tokens, with an <em>end of stream</em> token automatically added to the result.  The {RLTK::Lexer.lex_file} method takes the name of a file as input, and lexes the contents of the specified file.</p>

<h3>
<a name="the-lexing-environment" class="anchor" href="#the-lexing-environment"><span class="octicon octicon-link"></span></a>The Lexing Environment</h3>

<p>The proc objects passed to the {RLTK::Lexer.rule} methods are evaluated inside an instance of the {RLTK::Lexer::Environment} class.  This gives you access to methods for manipulating the lexer's state and flags (see bellow).  You can also subclass the environment inside your lexer to provide additional functionality to your rule blocks.  When doing so you need to ensure that you name your new class Environment like in the following example:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">MyLexer</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Lexer</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>

  <span class="k">class</span> <span class="nc">Environment</span> <span class="o">&lt;</span> <span class="no">Environment</span>
    <span class="k">def</span> <span class="nf">helper_function</span>
      <span class="o">.</span><span class="n">.</span><span class="o">.</span>
    <span class="k">end</span>

  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<h3>
<a name="using-states" class="anchor" href="#using-states"><span class="octicon octicon-link"></span></a>Using States</h3>

<p>The lexing environment may be used to keep track of state inside your lexer.  When rules are defined they are defined inside a given state, which is specified by the second parameter to {RLTK::Lexer.rule}.  The default state is cleverly named <code>:default</code>.  When the lexer is scanning the input string for matching rules, it only considers the rules for the given state.</p>

<p>The methods used to manipulate state are:</p>

<ul>
<li>
<strong>RLTK::Lexer::Environment.push_state</strong> - Pushes a new state onto the stack.</li>
<li>
<strong>RLTK::Lexer::Environment.pop_state</strong> - Pops a state off of the stack.</li>
<li>
<strong>RLTK::Lexer::Environment.set_state</strong> - Sets the state at the top of the stack.</li>
<li>
<strong>RLTK::Lexer::Environment.state</strong> - Returns the current state.</li>
</ul><p>States may be used to easily support nested comments.</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">StateLexer</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Lexer</span>
  <span class="n">rule</span><span class="p">(</span><span class="sr">/a/</span><span class="p">)</span> <span class="p">{</span> <span class="ss">:A</span> <span class="p">}</span>
  <span class="n">rule</span><span class="p">(</span><span class="sr">/\s/</span><span class="p">)</span>

  <span class="n">rule</span><span class="p">(</span><span class="sr">/\(\*/</span><span class="p">)</span> <span class="p">{</span> <span class="n">push_state</span><span class="p">(</span><span class="ss">:comment</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">rule</span><span class="p">(</span><span class="sr">/\(\*/</span><span class="p">,</span> <span class="ss">:comment</span><span class="p">)</span> <span class="p">{</span> <span class="n">push_state</span><span class="p">(</span><span class="ss">:comment</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">rule</span><span class="p">(</span><span class="sr">/\*\)/</span><span class="p">,</span> <span class="ss">:comment</span><span class="p">)</span> <span class="p">{</span> <span class="n">pop_state</span>            <span class="p">}</span>
  <span class="n">rule</span><span class="p">(</span><span class="sr">/./</span><span class="p">,</span>    <span class="ss">:comment</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

<p>By default the lexer will start in the <code>:default</code> state.  To change this, you may use the {RLTK::Lexer.start} method.</p>

<h3>
<a name="using-flags" class="anchor" href="#using-flags"><span class="octicon octicon-link"></span></a>Using Flags</h3>

<p>The lexing environment also maintains a set of <em>flags</em>.  This set is manipulated using the following methods:</p>

<ul>
<li>
<strong>RLTK::Lexer::Environment.set_flag</strong> - Adds the specified flag to the set of flags.</li>
<li>
<strong>RLTK::Lexer::Environment.unset_flag</strong> - Removes the specified flag from the set of flags.</li>
<li>
<strong>RLTK::Lexer::Environment.clear_flags</strong> - Unsets all flags.</li>
</ul><p>When <em>rules</em> are defined they may use a third parameter to specify a list of flags that must be set before the rule is considered when matching substrings.  An example of this usage follows:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">FlagLexer</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Lexer</span>
  <span class="n">rule</span><span class="p">(</span><span class="sr">/a/</span><span class="p">)</span> <span class="p">{</span> <span class="n">set_flag</span><span class="p">(</span><span class="ss">:a</span><span class="p">);</span> <span class="ss">:A</span> <span class="p">}</span>

  <span class="n">rule</span><span class="p">(</span><span class="sr">/\s/</span><span class="p">)</span>

  <span class="n">rule</span><span class="p">(</span><span class="sr">/b/</span><span class="p">,</span> <span class="ss">:default</span><span class="p">,</span> <span class="o">[</span><span class="ss">:a</span><span class="o">]</span><span class="p">)</span>     <span class="p">{</span> <span class="n">set_flag</span><span class="p">(</span><span class="ss">:b</span><span class="p">);</span> <span class="ss">:B</span> <span class="p">}</span>
  <span class="n">rule</span><span class="p">(</span><span class="sr">/c/</span><span class="p">,</span> <span class="ss">:default</span><span class="p">,</span> <span class="o">[</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:b</span><span class="o">]</span><span class="p">)</span> <span class="p">{</span> <span class="ss">:C</span>               <span class="p">}</span>
<span class="k">end</span>
</pre></div>

<h3>
<a name="instantiating-lexers" class="anchor" href="#instantiating-lexers"><span class="octicon octicon-link"></span></a>Instantiating Lexers</h3>

<p>In addition to using the {RLTK::Lexer.lex} class method you may also instantiate lexer objects.  The only difference then is that the lexing environment used between subsequent calls to {RLTK::Lexer#lex} is the same object, and therefor allows you to keep persistent state.</p>

<h3>
<a name="first-and-longest-match" class="anchor" href="#first-and-longest-match"><span class="octicon octicon-link"></span></a>First and Longest Match</h3>

<p>A RLTK::Lexer may be told to select either the first substring that is found to match a rule or the longest substring to match any rule.  The default behavior is to match the longest substring possible, but you can change this by using the {RLTK::Lexer.match_first} method inside your class definition as follows:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">MyLexer</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Lexer</span>
  <span class="n">match_first</span>

  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>
</pre></div>

<h3>
<a name="match-data" class="anchor" href="#match-data"><span class="octicon octicon-link"></span></a>Match Data</h3>

<p>Because it isn't RLTK's job to tell you how to write lexers and parsers, the MatchData object from a pattern match is available inside the Lexer::Environment object via the <code>match</code> accessor.</p>

<h2>
<a name="context-free-grammars" class="anchor" href="#context-free-grammars"><span class="octicon octicon-link"></span></a>Context-Free Grammars</h2>

<p>The {RLTK::CFG} class provides an abstraction for context-free grammars.  For the purpose of this class terminal symbols appear in <strong>ALL CAPS</strong>, and non-terminal symbols appear in <strong>all lowercase</strong>.  Once a grammar is defined the {RLTK::CFG#first_set} and {RLTK::CFG#follow_set} methods can be used to find <em>first</em> and <em>follow</em> sets.</p>

<h3>
<a name="defining-grammars" class="anchor" href="#defining-grammars"><span class="octicon octicon-link"></span></a>Defining Grammars</h3>

<p>A grammar is defined by first instantiating the {RLTK::CFG} class.  The {RLTK::CFG#production} and {RLTK::CFG#clause} methods may then be used to define the productions of the grammar.  The <code>production</code> method can take a Symbol denoting the left-hand side of the production and a string describing the right-hand side of the production, or the left-hand side symbol and a block.  In the first usage a single production is created.  In the second usage the block may contain repeated calls to the <code>clause</code> method, each call producing a new production with the same left-hand side but different right-hand sides.  {RLTK::CFG#clause} may not be called outside of {RLTK::CFG#production}.  Bellow we see a grammar definition that uses both methods:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">grammar</span> <span class="o">=</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CFG</span><span class="o">.</span><span class="n">new</span>

<span class="n">grammar</span><span class="o">.</span><span class="n">production</span><span class="p">(</span><span class="ss">:s</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">clause</span><span class="p">(</span><span class="s1">'A G D'</span><span class="p">)</span>
  <span class="n">clause</span><span class="p">(</span><span class="s1">'A a C'</span><span class="p">)</span>
  <span class="n">clause</span><span class="p">(</span><span class="s1">'B a D'</span><span class="p">)</span>
  <span class="n">clause</span><span class="p">(</span><span class="s1">'B G C'</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">grammar</span><span class="o">.</span><span class="n">production</span><span class="p">(</span><span class="ss">:a</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">)</span>
<span class="n">grammar</span><span class="o">.</span><span class="n">production</span><span class="p">(</span><span class="ss">:b</span><span class="p">,</span> <span class="s1">'G'</span><span class="p">)</span>
</pre></div>

<h3>
<a name="extended-backusnaur-form" class="anchor" href="#extended-backusnaur-form"><span class="octicon octicon-link"></span></a>Extended Backus–Naur Form</h3>

<p>The RLTK::CFG class understands grammars written in the extended Backus–Naur form.  This allows you to use the *, +, and ? operators in your grammar definitions.  When each of these operators are encountered additional productions are generated.  For example, if the right-hand side of a production contained <code>NUM*</code> a production of the form <code>num_star -&gt; | NUM num_star</code> is added to the grammar.  As such, your grammar should not contain productions with similar left-hand sides (e.g. foo_star, bar_question, or baz_plus).</p>

<p>As these additional productions are added internally to the grammar a callback functionality is provided to let you know when such an event occurs.  The callback proc object can either be specified when the CFG object is created, or by using the {RLTK::CFG#callback} method.  The callback will receive three arguments: the production generated, the operator that triggered the generation, and a symbol (:first or :second) specifying which clause of the production this callback is for.</p>

<h3>
<a name="helper-functions" class="anchor" href="#helper-functions"><span class="octicon octicon-link"></span></a>Helper Functions</h3>

<p>Once a grammar has been defined you can use the following functions to obtain information about it:</p>

<ul>
<li>{RLTK::CFG#first_set} - Returns the <em>first set</em> for the provided symbol or sentence.</li>
<li>{RLTK::CFG#follow_set} - Returns the <em>follow set</em> for the provided symbol.</li>
<li>{RLTK::CFG#nonterms} - Returns a list of the non-terminal symbols used in the grammar's definition.</li>
<li>{RLTK::CFG#productions} - Provides either a hash or array of the grammar's productions.</li>
<li>{RLTK::CFG#symbols} - Returns a list of all symbols used in the grammar's definition.</li>
<li>{RLTK::CFG#terms} - Returns a list of the terminal symbols used in the grammar's definition.</li>
</ul><h2>
<a name="parsers" class="anchor" href="#parsers"><span class="octicon octicon-link"></span></a>Parsers</h2>

<p>To create a parser using RLTK simply subclass RLTK::Parser, define the productions of the grammar you wish to parse, and call <code>finalize</code>.  During finalization RLTK will build an LALR(1) parsing table, which may contain conflicts that can't be resolved with LALR(1) lookahead sets or precedence/associativity information.  Traditionally, when parser generators such as <strong>YACC</strong> encounter conflicts during parsing table generation they will resolve shift/reduce conflicts in favor of shifts and reduce/reduce conflicts in favor of the production that was defined first.  This means that the generated parsers can't handle ambiguous grammars.</p>

<p>RLTK parsers, on the other hand, can handle <em>all</em> context-free grammars by forking the parse stack when shift/reduce or reduce/reduce conflicts are encountered.  This method is called the GLR parsing algorithm and allows the parser to explore multiple different possible derivations, discarding the ones that don't produce valid parse trees.  GLR parsing is more expensive, in both time and space requirements, but these penalties are only payed when a parser for an ambiguous grammar is given an input with multiple parse trees, and as such most parsing should proceed using the faster LALR(1) base algorithm.</p>

<h3>
<a name="defining-a-grammar" class="anchor" href="#defining-a-grammar"><span class="octicon octicon-link"></span></a>Defining a Grammar</h3>

<p>Let us look at the simple prefix calculator included with RLTK:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">PrefixCalc</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Parser</span>
  <span class="n">production</span><span class="p">(</span><span class="ss">:e</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'NUM'</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">n</span><span class="p">}</span>

    <span class="n">clause</span><span class="p">(</span><span class="s1">'PLS e e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">_</span><span class="p">,</span> <span class="n">e0</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">+</span> <span class="n">e1</span> <span class="p">}</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'SUB e e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">_</span><span class="p">,</span> <span class="n">e0</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">-</span> <span class="n">e1</span> <span class="p">}</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'MUL e e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">_</span><span class="p">,</span> <span class="n">e0</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">e1</span> <span class="p">}</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'DIV e e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">_</span><span class="p">,</span> <span class="n">e0</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">/</span> <span class="n">e1</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">finalize</span>
<span class="k">end</span>
</pre></div>

<p>The parser uses the same method for defining productions as the {RLTK::CFG} class.  In fact, the parser forwards the {RLTK::Parser.production} and {RLTK::Parser.clause} method invocations to an internal {RLTK::CFG} object after removing the parser specific information.  To see a detailed description of grammar definitions please read the Context-Free Grammars section bellow.</p>

<p>It is important to note that the proc objects associated with productions should evaluate to the value you wish the left-hand side of the production to take.</p>

<p>The default starting symbol of the grammar is the left-hand side of the first production defined (in this case, <em>e</em>).  This can be changed using the {RLTK::Parser.start} function when defining your parser.</p>

<p><strong>Make sure you call <code>finalize</code> at the end of your parser definition, and only call it once.</strong></p>

<h3>
<a name="shortcuts" class="anchor" href="#shortcuts"><span class="octicon octicon-link"></span></a>Shortcuts</h3>

<p>RLTK provides several shortcuts for common grammar constructs.  Right now these shortcuts include the {RLTK::Parser.empty_list} and {RLTK::Parser.nonempty_list} methods.  An empty list is a list that may contain 0, 1, or more elements, with an optional token or tokens seperating each element.  A non-empty list contains <strong>at least</strong> 1 element.  An empty list with only a single list element and an empty separator is equivelent to the Kleene star.  Simillarly, a nonempty list with only a single list element and an empty separator is equivelent to the Kleene plus.</p>

<p>This example shows how these shortcuts may be used to define a list of integers separated by a <code>:COMMA</code> token:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">ListParser</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Parser</span>
  <span class="n">nonempty_list</span><span class="p">(</span><span class="ss">:int_list</span><span class="p">,</span> <span class="ss">:INT</span><span class="p">,</span> <span class="ss">:COMMA</span><span class="p">)</span>

  <span class="n">finalize</span>
<span class="k">end</span>
</pre></div>

<p>If you wanted to define a list of floats or integers you could define your parser like this:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">ListParser</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Parser</span>
  <span class="n">nonempty_list</span><span class="p">(</span><span class="ss">:mixed_list</span><span class="p">,</span> <span class="o">[</span><span class="ss">:INT</span><span class="p">,</span> <span class="ss">:FLOAT</span><span class="o">]</span><span class="p">,</span> <span class="ss">:COMMA</span><span class="p">)</span>

  <span class="n">finalize</span>
<span class="k">end</span>
</pre></div>

<p>If you don't want to require a separator you can do this:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">ListParser</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Parser</span>
  <span class="n">nonempty_list</span><span class="p">(</span><span class="ss">:mixed_nonsep_list</span><span class="p">,</span> <span class="o">[</span><span class="ss">:INT</span><span class="p">,</span> <span class="ss">:FLOAT</span><span class="o">]</span><span class="p">)</span>

  <span class="n">finalize</span>
<span class="k">end</span>
</pre></div>

<p>You can also use separators that are made up of multiple tokens:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">ListParser</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Parser</span>
  <span class="n">nonempty_list</span><span class="p">(</span><span class="ss">:mixed_nonsep_list</span><span class="p">,</span> <span class="o">[</span><span class="ss">:INT</span><span class="p">,</span> <span class="ss">:FLOAT</span><span class="o">]</span><span class="p">,</span> <span class="s1">'COMMA NEWLINE?'</span><span class="p">)</span>

  <span class="n">finalize</span>
<span class="k">end</span>
</pre></div>

<p>A list may also contain multiple tokens between the separator:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">ListParser</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Parser</span>
  <span class="n">nonempty_list</span><span class="p">(</span><span class="ss">:foo_bar_list</span><span class="p">,</span> <span class="s1">'FOO BAR'</span><span class="p">,</span> <span class="ss">:COMMA</span><span class="p">)</span>

  <span class="n">finalize</span>
<span class="k">end</span>
</pre></div>

<p>Lastly, you can mix all of these features together:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">ListParser</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Parser</span>
  <span class="n">nonempty_list</span><span class="p">(</span><span class="ss">:foo_list</span><span class="p">,</span> <span class="o">[</span><span class="s1">'FOO BAR'</span><span class="p">,</span> <span class="s1">'FOO BAZ+'</span><span class="o">]</span><span class="p">,</span> <span class="ss">:COMMA</span><span class="p">)</span>

  <span class="n">finalize</span>
<span class="k">end</span>
</pre></div>

<p>The productions generated by these shortcuts will always evaluate to an array.  In the first two examples above the productions will produce a 1-D array containing the values of the <code>INT</code> or <code>FLOAT</code> tokens.  In the last two examples the productions <code>foo_bar_list</code> and <code>foo_list</code> will produce 2-D arrays where the top level array is composed of tuples coresponding to the values of <code>FOO</code>, and <code>BAR</code> or one or more <code>BAZ</code>s.</p>

<h3>
<a name="precedence-and-associativity" class="anchor" href="#precedence-and-associativity"><span class="octicon octicon-link"></span></a>Precedence and Associativity</h3>

<p>To help you remove ambiguity from your grammars RLTK lets you assign precedence and associativity information to terminal symbols.  Productions then get assigned precedence and associativity based on either the last terminal symbol on the right-hand side of the production, or an optional parameter to the {RLTK::Parser.production} or {RLTK::Parser.clause} methods.  When an {RLTK::Parser} encounters a shift/reduce error it will attempt to resolve it using the following rules:</p>

<ol>
<li><p>If there is precedence and associativity information present for all reduce actions involved and for the input token we attempt to resolve the conflict using the following rule.  If not, no resolution is possible and the parser generator moves on.  This conflict will later be reported to the programmer.</p></li>
<li><p>The precedence of the actions involved in the conflict are compared (a shift action's precedence is based on the input token), and the action with the highest precedence is selected.  If two actions have the same precedence the associativity of the input symbol is used: left associativity means we select the reduce action, right associativity means we select the shift action, and non-associativity means that we have encountered an error.</p></li>
</ol><p>To assign precedence to terminal symbols you can use the {RLTK::Parser.left}, {RLTK::Parser.right}, and {RLTK::Parser.nonassoc} methods inside your parser class definition.  Later declarations of associativity have higher levels of precedence than earlier declarations of the same associativity.</p>

<p>Let's look at the infix calculator example now:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">InfixCalc</span> <span class="o">&lt;</span> <span class="no">Parser</span>

  <span class="n">left</span>  <span class="ss">:PLS</span><span class="p">,</span> <span class="ss">:SUB</span>
  <span class="n">right</span> <span class="ss">:MUL</span><span class="p">,</span> <span class="ss">:DIV</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:e</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'NUM'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">n</span> <span class="p">}</span>

    <span class="n">clause</span><span class="p">(</span><span class="s1">'LPAREN e RPAREN'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">_</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">_</span><span class="o">|</span> <span class="n">e</span> <span class="p">}</span>

    <span class="n">clause</span><span class="p">(</span><span class="s1">'e PLS e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">e0</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">+</span> <span class="n">e1</span> <span class="p">}</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'e SUB e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">e0</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">-</span> <span class="n">e1</span> <span class="p">}</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'e MUL e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">e0</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">e1</span> <span class="p">}</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'e DIV e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">e0</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">/</span> <span class="n">e1</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">finalize</span>
<span class="k">end</span>
</pre></div>

<p>The standard order of mathematical operations tells us that the correct way to group the operations in the expression <code>2 + 3 * 4</code> is <code>2 + (3 * 4)</code>.  However, our grammar tells us that <code>(2 + 3) * 5</code> is also a valid way to parse the expression, leading to a shift/reduce error in the parser.  To get rid of the shift/reduce error we need some way to tell the parser how to distinguish between these two parse trees.  This is where associativity comes in.  If the parser has already read <code>NUM PLS NUM</code> and the current symbol is a <code>MUL</code> symbol we want to tell the parser to shift the new <code>MUL</code> symbol onto the stack and continue on.  We do this by making the <code>MUL</code> symbol right associative.  When the parser generator encounters a shift/reduce error it looks at the token currently being read.  If it has no associativity information, the error can't be resolved; if the token is left associative, it will remove the shift action from the parser (leaving only the reduce action); if the token is right associative, it will remove the reduce action from the parser (leaving only the shift action).</p>

<p>Now, let us consider the expression <code>3 - 2 - 1</code>.  Here, the correct way to parse the expression is <code>(3 - 2) - 2</code>.  To ensure that this case is selected over <code>3 - (2 - 1)</code> we can make the <code>SUB</code> token left associative.  This will cause the symbols <code>NUM SUB NUM</code> to be reduced before the second <code>SUB</code> symbol is shifted onto the parse stack.</p>

<p>Not that, to resolve a shift/reduce or reduce/reduce conflict, precedence and associativty information must be present for all actions involved in the conflict.  As such, it isn't enough to simply make the <code>MUL</code> and <code>DIV</code> tokens right associative; we must also make the <code>PLS</code> and <code>SUB</code> tokens left associative.</p>

<h3>
<a name="argument-passing-for-actions" class="anchor" href="#argument-passing-for-actions"><span class="octicon octicon-link"></span></a>Argument Passing for Actions</h3>

<p>By default the proc objects associated with productions are passed one argument for each symbol on the right-hand side of the production.  This can lead to long, unwieldy argument lists.  To change this behaviour you can use the {RLTK::Parser.default_arg_type} method, which accepts the <code>:splat</code> (default) and <code>:array</code> arguments.  Any production actions that are defined after a call to {RLTK::Parser.default_arg_type} will use the argument passing method currently set as the default.  You can switch between the different argument passing methods by calling {RLTK::Parser.default_arg_type} repeatedly.</p>

<p>Individual productions may specify the argument type used by their action via the <code>arg_type</code> parameter.  If the {RLTK::Parser.production} method is passed an argument type and a block, any clauses defined inside the block will use the argument type specified by the <code>arg_type</code> parameter.</p>

<h3>
<a name="the-parsing-environment" class="anchor" href="#the-parsing-environment"><span class="octicon octicon-link"></span></a>The Parsing Environment</h3>

<p>The parsing environment is the context in which the proc objects associated with productions are evaluated, and can be used to provide helper functions and to keep state while parsing.  To define a custom environment simply subclass {RLTK::Parser::Environment} inside your parser definition as follows:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">MyParser</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Parser</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>

  <span class="k">class</span> <span class="nc">Environment</span> <span class="o">&lt;</span> <span class="no">Environment</span>
    <span class="k">def</span> <span class="nf">helper_function</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
    <span class="k">end</span>

  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>

  <span class="n">finalize</span>
<span class="k">end</span>
</pre></div>

<p>(The definition of the Environment class may occur anywhere inside the MyParser class definition.)</p>

<h3>
<a name="instantiating-parsers" class="anchor" href="#instantiating-parsers"><span class="octicon octicon-link"></span></a>Instantiating Parsers</h3>

<p>In addition to using the {RLTK::Parser.parse} class method you may also instantiate parser objects.  The only difference then is that the parsing environment used between subsequent calls to {RLTK::Parser#parse} is the same object, and therefor allows you to keep persistent state.</p>

<h3>
<a name="finalization-options" class="anchor" href="#finalization-options"><span class="octicon octicon-link"></span></a>Finalization Options</h3>

<p>The {RLTK::Parser.finalize} method has several options that you should be aware of:</p>

<ul>
<li><p><strong>explain</strong> - Value should be <code>true</code>, <code>false</code>, an <code>IO</code> object, or a file name.  Default value is <code>false</code>.  If a non <code>false</code> (or <code>nil</code>) value is specified <code>finalize</code> will print an explanation of the parser to $stdout, the provided <code>IO</code> object, or the specified file.  This explanation will include all of the productions defined, all of the terminal symbols used in the grammar definition, and the states present in the parsing table along with their items, actions, and conflicts.</p></li>
<li><p><strong>lookahead</strong> - Either <code>true</code> or <code>false</code>.  Default value is <code>true</code>.  Specifies whether the parser generator should build an LALR(1) or LR(0) parsing table.  The LALR(1) table may have the same actions as the LR(0) table or fewer reduce actions if it is possible to resolve conflicts using lookahead sets.</p></li>
<li><p><strong>precedence</strong> - Either <code>true</code> or <code>false</code>.  Default value is <code>true</code>.  Specifies whether the parser generator should use precedence and associativity information to solve conflicts.</p></li>
<li><p><strong>use</strong> - Value should be <code>false</code>, the name of a file, or a file object.  If the file exists and hasn't been modified since the parser definition was RLTK will load the parser definition from the file, saving a bunch of time.  If the file doesn't exist or the parser has been modified since it was last used RLTK will save the parser's data structures to this file.</p></li>
</ul><h3>
<a name="parsing-options" class="anchor" href="#parsing-options"><span class="octicon octicon-link"></span></a>Parsing Options</h3>

<p>The {RLTK::Parser.parse} and {RLTK::Parser#parse} methods also have several options that you should be aware of:</p>

<ul>
<li><p><strong>accept</strong> - Either <code>:first</code> or <code>:all</code>.  Default value is <code>:first</code>.  This option tells the parser to accept the first successful parse-tree found, or all parse-trees that enter the accept state.  It only affects the behavior of the parser if the defined grammar is ambiguous.</p></li>
<li><p><strong>env</strong> - This option specifies the environment in which the productions' proc objects are evaluated.  The RLTK::Parser::parse class function will create a new RLTK::Parser::Environment on each call unless one is specified.  RLTK::Parser objects have an internal, per-instance, RLTK::Parser::Environment that is the default value for this option when calling RLTK::Parser.parse</p></li>
<li><p><strong>parse_tree</strong> - Value should be <code>true</code>, <code>false</code>, an <code>IO</code> object, or a file name.  Default value is <code>false</code>.  If a non <code>false</code> (or <code>nil</code>) value is specified a DOT language description of all accepted parse trees will be printed out to $stdout, the provided <code>IO</code> object, or the specified file.</p></li>
<li><p><strong>verbose</strong> - Value should be <code>true</code>, <code>false</code>, an <code>IO</code> object, or a file name.  Default value is <code>false</code>.  If a non <code>false</code> (or <code>nil</code>) value is specified a detailed description of the actions of the parser are printed to $stdout, the provided <code>IO</code> object, or the specified file as it parses the input.</p></li>
</ul><h3>
<a name="parse-trees" class="anchor" href="#parse-trees"><span class="octicon octicon-link"></span></a>Parse Trees</h3>

<p>The above section briefly mentions the <em>parse_tree</em> option.  So that this neat feature doesn't get lost in the rest of the documentation here is the tree generated by the Kazoo parser from Chapter 7 of the tutorial when it parses the line <code>def fib(a) if a &lt; 2 then 1 else fib(a-1) + fib(a-2);</code>:</p>

<p><img src="https://github.com/chriswailes/RLTK/raw/master/resources/simple_tree.png" alt="Kazoo parse tree."></p>

<h3>
<a name="parsing-exceptions" class="anchor" href="#parsing-exceptions"><span class="octicon octicon-link"></span></a>Parsing Exceptions</h3>

<p>Calls to {RLTK::Parser.parse} may raise one of four exceptions:</p>

<ul>
<li>
<strong>RLTK::BadToken</strong> - This exception is raised when a token is observed in the input stream that wasn't used in the language's definition.</li>
<li>
<strong>RLTK::HandledError</strong> - This exception is raised whenever an error production is encountered.  The input stream is not actually in the langauge, but we were able to handle the encountered errors in a way that makes it appear that it is.</li>
<li>
<strong>RLTK::InternalParserError</strong> - This exception tells you that something REALLY went wrong.  Users should never receive this exception.</li>
<li>
<strong>RLTK::NotInLanguage</strong> - This exception indicates that the input token stream is not in the parser's language.</li>
</ul><h3>
<a name="error-productions" class="anchor" href="#error-productions"><span class="octicon octicon-link"></span></a>Error Productions</h3>

<p><strong>Warning: this is the lest tested feature of RLTK.  If you encounter any problems while using it, please let me know so I can fix any bugs as soon as possible.</strong></p>

<p>When an RLTK parser encounters a token for which there are no more valid actions (and it is on the last parse stack / possible parse-tree path) it will enter error handling mode.  In this mode the parser pops states and input off of the parse stack (the parser is a pushdown automaton after all) until it finds a state that has a shift action for the <code>ERROR</code> terminal.  A dummy <code>ERROR</code> terminal is then placed onto the parse stack and the shift action is taken.  This error token will have the position information of the token that caused the parser to enter error handling mode.  Additional tokens may have been discarded after this token.</p>

<p>If the input (including the <code>ERROR</code> token) can be reduced immediately the associated error handling proc is evaluated and we continue parsing.  If no shift or reduce action is available the parser will being shifting tokens off of the input stack until a token appears with a valid action in the current state, in which case parsing resumes as normal.</p>

<p>The value of an <code>ERROR</code> non-terminal will be an array containing all of the tokens that were discarded while the parser was searching for a valid action.</p>

<p>The example below, based on one of the unit tests, shows a very basic usage of error productions:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">ErrorCalc</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">Parser</span>
  <span class="n">left</span>  <span class="ss">:ERROR</span>
  <span class="n">right</span> <span class="ss">:PLS</span><span class="p">,</span> <span class="ss">:SUB</span><span class="p">,</span> <span class="ss">:MUL</span><span class="p">,</span> <span class="ss">:DIV</span><span class="p">,</span> <span class="ss">:NUM</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:e</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'NUM'</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">n</span><span class="p">}</span>

    <span class="n">clause</span><span class="p">(</span><span class="s1">'e PLS e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">e0</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">+</span> <span class="n">e1</span> <span class="p">}</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'e SUB e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">e0</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">-</span> <span class="n">e1</span> <span class="p">}</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'e MUL e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">e0</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">e1</span> <span class="p">}</span>
    <span class="n">clause</span><span class="p">(</span><span class="s1">'e DIV e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">e0</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">e0</span> <span class="o">/</span> <span class="n">e1</span> <span class="p">}</span>

    <span class="n">clause</span><span class="p">(</span><span class="s1">'e PLS ERROR e'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">e0</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">e1</span><span class="o">|</span> <span class="n">error</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">err</span><span class="o">.</span><span class="n">len</span><span class="si">}</span><span class="s2"> tokens skipped."</span><span class="p">);</span> <span class="n">e0</span> <span class="o">+</span> <span class="n">e1</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">finalize</span>
<span class="k">end</span>
</pre></div>

<h2>
<a name="a-note-on-token-naming" class="anchor" href="#a-note-on-token-naming"><span class="octicon octicon-link"></span></a>A Note on Token Naming</h2>

<p>In the world of RLTK both terminal and non-terminal symbols may contain only alphanumeric characters and underscores.  The differences between terminal and non-terminal symbols is that terminals are <strong>ALL_UPPER_CASE</strong> and non-terminals are <strong>all_lower_case</strong>.</p>

<h2>
<a name="astnode" class="anchor" href="#astnode"><span class="octicon octicon-link"></span></a>ASTNode</h2>

<p>The {RLTK::ASTNode} base class is meant to be a good starting point for implementing your own abstract syntax tree nodes.  By subclassing {RLTK::ASTNode} you automagically get features such as tree comparison, notes, value accessors with type checking, child node accessors and <code>each</code> and <code>map</code> methods (with type checking), and the ability to retrieve the root of a tree from any member node.</p>

<p>To create your own AST node classes you subclass the {RLTK::ASTNode} class and then use the {RLTK::ASTNode.child} and {RLTK::ASTNode.value} methods.  By declaring the children and values of a node the class will define the appropriate accessors with type checking, know how to pack and unpack a node's children, and know how to handle constructor arguments.</p>

<p>Here we can see the definition of several AST node classes that might be used to implement binary operations for a language:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">Expression</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">ASTNode</span><span class="p">;</span> <span class="k">end</span>

<span class="k">class</span> <span class="nc">Number</span> <span class="o">&lt;</span> <span class="no">Expression</span>
  <span class="n">value</span> <span class="ss">:value</span><span class="p">,</span> <span class="no">Fixnum</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">BinOp</span> <span class="o">&lt;</span> <span class="no">Expression</span>
  <span class="n">value</span> <span class="ss">:op</span><span class="p">,</span> <span class="nb">String</span>

  <span class="n">child</span> <span class="ss">:left</span><span class="p">,</span>  <span class="no">Expression</span>
  <span class="n">child</span> <span class="ss">:right</span><span class="p">,</span> <span class="no">Expression</span>
<span class="k">end</span>
</pre></div>

<p>The assignment functions that are generated for the children and values perform type checking to make sure that the AST is well-formed.  The type of a child must be a subclass of the {RLTK::ASTNode} class, whereas the type of a value must <strong>NOT</strong> be a subclass of the {RLTK::ASTNode} class.  While child and value objects are stored as instance variables it is unsafe to assign to these variables directly, and it is strongly recommended to always use the accessor functions.</p>

<p>When instantiating a subclass of {RLTK::ASTNode} the arguments to the constructor should be the node's values (in order of definition) followed by the node's children (in order of definition).  If a constructor is given fewer arguments then the number of values and children the remaining arguments are assumed to be <code>nil</code>.  Example:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">ASTNode</span>
  <span class="n">value</span> <span class="ss">:a</span><span class="p">,</span> <span class="no">Fixnum</span>
  <span class="n">child</span> <span class="ss">:b</span><span class="p">,</span> <span class="no">Bar</span>
  <span class="n">value</span> <span class="ss">:c</span><span class="p">,</span> <span class="nb">String</span>
  <span class="n">child</span> <span class="ss">:d</span><span class="p">,</span> <span class="no">Bar</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Bar</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">ASTNode</span>
  <span class="n">value</span> <span class="ss">:a</span><span class="p">,</span> <span class="nb">String</span>
<span class="k">end</span>

<span class="no">Foo</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'baz'</span><span class="p">,</span> <span class="no">Bar</span><span class="o">.</span><span class="n">new</span><span class="p">)</span>
</pre></div>

<p>Lastly, the type of a child or value can be defined as an array of objects of a specific type as follows:</p>

<div class="highlight highlight-Ruby"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="o">&lt;</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">ASTNode</span>
  <span class="n">value</span> <span class="ss">:strings</span><span class="p">,</span> <span class="o">[</span><span class="nb">String</span><span class="o">]</span>
<span class="k">end</span>
</pre></div>

<h3>
<a name="tree-iteration-and-mapping" class="anchor" href="#tree-iteration-and-mapping"><span class="octicon octicon-link"></span></a>Tree Iteration and Mapping</h3>

<p>RLTK Abstract Syntax Trees may be <a href="http://en.wikipedia.org/wiki/Tree_traversal">traversed</a> in three different ways:</p>

<ul>
<li>Pre-order</li>
<li>Post-order</li>
<li>Level-order</li>
</ul><p>The order you wish to traverse the tree can be specified by passing the appropriate symbol to {RLTK::ASTNode#each}: <code>:pre</code>, <code>:post</code>, or <code>:level</code>.</p>

<p>You can also map one tree to another tree using the {RLTK::ASTNode#map} and {RLTK::ASTNode#map!} methods.  In the former case a new tree is created and returned; in the latter case the current tree is transformed and the result of calling the provided block on the root node is returned.  These methods will always visit nodes in <em>post-order</em>, so that all children of a node are visited before the node itself.</p>

<h2>
<a name="code-generation" class="anchor" href="#code-generation"><span class="octicon octicon-link"></span></a>Code Generation</h2>

<p>RLTK supports the generation of native code and LLVM IR, as well as JIT compilation and execution, through the {RLTK::CG} module.  This module is built on top of bindings to <a href="http://llvm.org">LLVM</a> and provides much, though not all, of the functionality of the LLVM libraries.</p>

<h3>
<a name="acknowledgments-and-discussion" class="anchor" href="#acknowledgments-and-discussion"><span class="octicon octicon-link"></span></a>Acknowledgments and Discussion</h3>

<p>Before we get started with the details, I would like to thank <a href="https://github.com/jvoorhis/">Jeremy Voorhis</a>.  The bindings present in RLTK are really a fork of the great work that he did on <a href="https://github.com/jvoorhis/ruby-llvm">ruby-llvm</a>.</p>

<p>Why did I fork ruby-llvm, and why might you want to use the RLTK bindings over ruby-llvm?  There are a couple of reasons:</p>

<ul>
<li>
<strong>Cleaner Codebase</strong> - The RLTK bindings present a cleaner interface to the LLVM library by conforming to more standard Ruby programming practices, providing better abstractions and cleaner inheritance hierarchies, overloading constructors and other methods properly, and performing type checking on objects to better aid in debugging.</li>
<li>
<strong>Documentation</strong> - RLTK's bindings provide better documentation.</li>
<li>
<strong>Completeness</strong> - The RLTK bindings provide several features that are missing from the ruby-llvm project.  These include the ability to initialize LLVM for architectures besides x86 (RLTK supports all architectures supported by LLVM), the presence of all of LLVM's optimization passes, the ability to print the LLVM IR representation of modules and values to files and load modules <em>from</em> files, easy initialization of native architectures, initialization for ASM printers and parsers, and compiling modules to object files.</li>
<li>
<strong>Ease of Use</strong> - Several features have been added to make generating code easier such as automatic management of memory resources used by LLVM.</li>
<li>
<strong>Speed</strong> - The RLTK bindings are ever so slightly faster due to avoiding unnecessary FFI calls.</li>
</ul><p>Before you dive into generating code, here are some resources you might want to look over to build up some background knowledge on how LLVM works:</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">Static Single Assignment Form</a></li>
<li><a href="http://llvm.org/docs/LangRef.html">LLVM Intermediate Representation</a></li>
</ul><h3>
<a name="llvm" class="anchor" href="#llvm"><span class="octicon octicon-link"></span></a>LLVM</h3>

<p>Since RLTK's code generation functionality is built on top of LLVM the first step in generating code is to inform LLVM of the target architecture.  This is accomplished via the {RLTK::CG::LLVM.init} method, which is used like this: <code>RLTK::CG::LLVM.init(:PPC)</code>.  The {RLTK::CG::Bindings::ARCHS} constant provides a list of supported architectures.  This call must appear before any other calls to the RLTK::CG module.</p>

<p>If you would like to see what version of LLVM is targeted by your version of RLTK you can either call the {RLTK::CG::LLVM.version} method or looking at the {RLTK::LLVM_TARGET_VERSION} constant.</p>

<h3>
<a name="modules" class="anchor" href="#modules"><span class="octicon octicon-link"></span></a>Modules</h3>

<p>Modules are one of the core building blocks of the code generation module.  Functions, constants, and global variables all exist inside a particular module and, if you use the JIT compiler, a module provides the context for your executing code.  New modules can be created using the {RLTK::CG::Module#initialize RLTK::CG::Module.new} method.  While this method is overloaded you, as a library user, will always pass it a string as its first argument.  This allows you to name your modules for easier debugging later.</p>

<p>Once you have created you can serialize the code inside of it into <em>bitcode</em> via the {RLTK::CG::Module#write_bitcode} method.  This allows you to save partially generated code and then use it later.  To load a module from <em>bitcode</em> you use the {RLTK::CG::Module.read_bitcode} method.</p>

<h3>
<a name="types" class="anchor" href="#types"><span class="octicon octicon-link"></span></a>Types</h3>

<p>Types are an important part of generating code using LLVM.  Functions, operations, and other constructs use types to make sure that the generated code is sane.  All types in RLTK are subclasses of the {RLTK::CG::Type} class, and have class names that end in "Type".  Types can be grouped into to categories: fundamental and composite.</p>

<p>Fundamental types are those like {RLTK::CG::Int32Type} and {RLTK::CG::FloatType} that don't take any arguments when they are created.  Indeed, these types are represented using a Singleton class, and so the <code>new</code> method is disabled.  Instead you can use the <code>instance</code> method to get an instantiated type, or simply pass in the class itself whenever you need to reference the type.  In this last case, the method you pass the class to will instantiate the type for you.</p>

<p>Composite types are constructed from other types.  These include the {RLTK::CG::ArrayType}, {RLTK::CG::FunctionType}, and other classes.  These types you must instantiate directly before they can be used, and you may not simply pass the type class as the type argument to functions inside the RLTK::CG module.</p>

<p>For convenience, the native integer type of the host platform is made available via {RLTK::CG::NativeIntType}.</p>

<h3>
<a name="values" class="anchor" href="#values"><span class="octicon octicon-link"></span></a>Values</h3>

<p>The {RLTK::CG::Value} class is the common ancestor of many classes inside the RLTK::CG module.  The main way in which you, the library user, will interact with them is when creating constant values.  Here is a list of some of value classes you might use:</p>

<ul>
<li>{RLTK::CG::Int1}</li>
<li>{RLTK::CG::Int8}</li>
<li>{RLTK::CG::Int16}</li>
<li>{RLTK::CG::Int32}</li>
<li>{RLTK::CG::Int64}</li>
<li>{RLTK::CG::Float}</li>
<li>{RLTK::CG::Double}</li>
<li>{RLTK::CG::ConstantArray}</li>
<li>{RLTK::CG::ConstantStruct}</li>
</ul><p>Again, for convenience, the native integer class of the host platform is made available via {RLTK::CG::NativeInt}.</p>

<h3>
<a name="functions" class="anchor" href="#functions"><span class="octicon octicon-link"></span></a>Functions</h3>

<p>Functions in LLVM are much like C functions; they have a return type, argument types, and a body.  Functions may be created in several ways, though they all require a module in which to place the function.</p>

<p>The first way to create functions is via a module's function collection:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">mod</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'my function'</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span>
</pre></div>

<p>Here we have defined a function named 'my function' in the <code>mod</code> module.  It takes two native integers as arguments and returns a native integer.  It is also possible to define the type of a function ahead of time and pass it to this method:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">type</span> <span class="o">=</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">FunctionType</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span>
<span class="n">mod</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'my function'</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span>
</pre></div>

<p>Functions may also be created directly via the {RLTK::CG::Function#initialize RLTK::CG::Function.new} method, though a reference to a module is still necessary:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">mod</span> <span class="o">=</span> <span class="no">Module</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">'my module'</span><span class="p">)</span>
<span class="n">fun</span> <span class="o">=</span> <span class="no">Function</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="s1">'my function'</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span>
</pre></div>

<p>or</p>

<div class="highlight highlight-Ruby"><pre><span class="n">mod</span>  <span class="o">=</span> <span class="no">Module</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">'my module'</span><span class="p">)</span>
<span class="n">type</span> <span class="o">=</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">FunctionType</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span>
<span class="n">fun</span>  <span class="o">=</span> <span class="no">Function</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="s1">'my function'</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span>
</pre></div>

<p>Lastly, whenever you use one of these methods to create a function you may give it a block to be executed inside the context of the function object.  This allows for easier building of functions:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">mod</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'my function'</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">bb</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'entry)'</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>
</pre></div>

<h3>
<a name="basic-blocks" class="anchor" href="#basic-blocks"><span class="octicon octicon-link"></span></a>Basic Blocks</h3>

<p>Once a function has been added to a module you will need to add {RLTK::CG::BasicBlock BasicBlocks} to the function.  This can be done easily:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">bb</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'entry'</span><span class="p">)</span>
</pre></div>

<p>We now have a basic block that we can use to add instructions to our function and get it to actually do something.  You can also instantiate basic blocks directly:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">bb</span> <span class="o">=</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">BasicBlock</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="s1">'entry'</span><span class="p">)</span>
</pre></div>

<h3>
<a name="the-builder" class="anchor" href="#the-builder"><span class="octicon octicon-link"></span></a>The Builder</h3>

<p>Now that you have a basic block you need to add instructions to it.  This is accomplished using a {RLTK::CG::Builder builder}, either directly or indirectly.</p>

<p>To add instructions using a builder directly (this is most similar to how it is done using C/C++) you create the builder, position it where you want to add instructions, and then build them:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">fun</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'add'</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span>
<span class="n">bb</span>  <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'entry'</span><span class="p">)</span>

<span class="n">builder</span> <span class="o">=</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">Builder</span><span class="o">.</span><span class="n">new</span>

<span class="n">builder</span><span class="o">.</span><span class="n">position_at_end</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>

<span class="c1"># Generate an add instruction.</span>
<span class="n">inst0</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>

<span class="c1"># Generate a return instruction.</span>
<span class="n">builder</span><span class="o">.</span><span class="n">ret</span><span class="p">(</span><span class="n">inst0</span><span class="p">)</span>
</pre></div>

<p>You can get rid of some of those references to the builder by using the {RLTK::CG::Builder#build} method:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">fun</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'add'</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span>
<span class="n">bb</span>  <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'entry'</span><span class="p">)</span>

<span class="n">builder</span> <span class="o">=</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">Builder</span><span class="o">.</span><span class="n">new</span>

<span class="n">builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">ret</span> <span class="n">add</span><span class="p">(</span><span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

<p>To get rid of more code:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">fun</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'add'</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span>
<span class="n">bb</span>  <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'entry'</span><span class="p">)</span>

<span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">Builder</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">ret</span> <span class="n">add</span><span class="p">(</span><span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

<p>or</p>

<div class="highlight highlight-Ruby"><pre><span class="n">fun</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'add'</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span>
<span class="n">fun</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'entry'</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">ret</span> <span class="n">add</span><span class="p">(</span><span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

<p>or even</p>

<div class="highlight highlight-Ruby"><pre><span class="n">mod</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'add'</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'entry'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">fun</span><span class="o">|</span>
    <span class="n">ret</span> <span class="n">add</span><span class="p">(</span><span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>In the last two examples a new builder object is created for the block.  It is possible to specify the builder to be used:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">builder</span> <span class="o">=</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">Builder</span><span class="o">.</span><span class="n">new</span>

<span class="n">mod</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'add'</span><span class="p">,</span> <span class="ss">RLTK</span><span class="p">:</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'entry'</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">fun</span><span class="o">|</span>
    <span class="n">ret</span> <span class="n">add</span><span class="p">(</span><span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>For an example of where this is useful, see the Kazoo tutorial.</p>

<h3>
<a name="the-contractor" class="anchor" href="#the-contractor"><span class="octicon octicon-link"></span></a>The Contractor</h3>

<p>An alternative to using the {RLTK::CG::Builder} class is to use the {RLTK::CG::Contractor} class, which is a subclass of the Builder and includes the Filigree::Visitor module. (Get it? It's a visiting builder!)  By subclassing the Contractor you can define blocks of code for handling various types of AST nodes and leave the selection of the correct code up to the {RLTK::CG::Contractor#visit} method.  In addition, the <code>:at</code> and <code>:rcb</code> options to the <em>visit</em> method make it much easier to manage the positioning of the Builder.</p>

<p>Here we can see how easy it is to define a block that builds the instructions for binary operations:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">on</span> <span class="no">Binary</span> <span class="k">do</span> <span class="o">|</span><span class="n">node</span><span class="o">|</span>
  <span class="n">left</span>  <span class="o">=</span> <span class="n">visit</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
  <span class="n">right</span> <span class="o">=</span> <span class="n">visit</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span>

  <span class="k">case</span> <span class="n">node</span>
    <span class="k">when</span> <span class="no">Add</span> <span class="k">then</span> <span class="n">fadd</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s1">'addtmp'</span><span class="p">)</span>
    <span class="k">when</span> <span class="no">Sub</span> <span class="k">then</span> <span class="n">fsub</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s1">'subtmp'</span><span class="p">)</span>
    <span class="k">when</span> <span class="no">Mul</span> <span class="k">then</span> <span class="n">fmul</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s1">'multmp'</span><span class="p">)</span>
    <span class="k">when</span> <span class="no">Div</span> <span class="k">then</span> <span class="n">fdiv</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s1">'divtmp'</span><span class="p">)</span>
    <span class="k">when</span> <span class="no">LT</span>  <span class="k">then</span> <span class="n">ui2fp</span><span class="p">(</span><span class="n">fcmp</span><span class="p">(</span><span class="ss">:ult</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s1">'cmptmp'</span><span class="p">),</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">DoubleType</span><span class="p">,</span> <span class="s1">'booltmp'</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>AST nodes whos translation requires the generation of control flow will require the creation of new BasicBlocks and the repositioning of the builder.  This can be easily managed:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">on</span> <span class="no">If</span> <span class="k">do</span> <span class="o">|</span><span class="n">node</span><span class="o">|</span>
  <span class="n">cond_val</span> <span class="o">=</span> <span class="n">visit</span> <span class="n">node</span><span class="o">.</span><span class="n">cond</span>
  <span class="n">fcmp</span> <span class="ss">:one</span><span class="p">,</span> <span class="n">cond_val</span><span class="p">,</span> <span class="no">ZERO</span><span class="p">,</span> <span class="s1">'ifcond'</span>

  <span class="n">start_bb</span> <span class="o">=</span> <span class="n">current_block</span>
  <span class="n">fun</span>      <span class="o">=</span> <span class="n">start_bb</span><span class="o">.</span><span class="n">parent</span>

  <span class="n">then_bb</span>               <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'then'</span><span class="p">)</span>
  <span class="n">then_val</span><span class="p">,</span> <span class="n">new_then_bb</span> <span class="o">=</span> <span class="n">visit</span> <span class="n">node</span><span class="o">.</span><span class="n">then</span><span class="p">,</span> <span class="ss">at</span><span class="p">:</span> <span class="n">then_bb</span><span class="p">,</span> <span class="ss">rcb</span><span class="p">:</span> <span class="kp">true</span>

  <span class="n">else_bb</span>               <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'else'</span><span class="p">)</span>
  <span class="n">else_val</span><span class="p">,</span> <span class="n">new_else_bb</span> <span class="o">=</span> <span class="n">visit</span> <span class="n">node</span><span class="o">.</span><span class="n">else</span><span class="p">,</span> <span class="ss">at</span><span class="p">:</span> <span class="n">else_bb</span><span class="p">,</span> <span class="ss">rcb</span><span class="p">:</span> <span class="kp">true</span>

  <span class="n">merge_bb</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'merge'</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
  <span class="n">phi_inst</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">merge_bb</span><span class="p">)</span> <span class="p">{</span> <span class="n">phi</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">DoubleType</span><span class="p">,</span> <span class="p">{</span><span class="n">new_then_bb</span> <span class="o">=&gt;</span> <span class="n">then_val</span><span class="p">,</span> <span class="n">new_else_bb</span> <span class="o">=&gt;</span> <span class="n">else_val</span><span class="p">},</span> <span class="s1">'iftmp'</span> <span class="p">}</span>

  <span class="n">build</span><span class="p">(</span><span class="n">start_bb</span><span class="p">)</span> <span class="p">{</span> <span class="n">cond</span> <span class="n">cond_val</span><span class="p">,</span> <span class="n">then_bb</span><span class="p">,</span> <span class="n">else_bb</span> <span class="p">}</span>

  <span class="n">build</span><span class="p">(</span><span class="n">new_then_bb</span><span class="p">)</span> <span class="p">{</span> <span class="n">br</span> <span class="n">merge_bb</span> <span class="p">}</span>
  <span class="n">build</span><span class="p">(</span><span class="n">new_else_bb</span><span class="p">)</span> <span class="p">{</span> <span class="n">br</span> <span class="n">merge_bb</span> <span class="p">}</span>

  <span class="n">returning</span><span class="p">(</span><span class="n">phi_inst</span><span class="p">)</span> <span class="p">{</span> <span class="n">target</span> <span class="n">merge_bb</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>

<p>More extensive examples of how to use the Contractor class can be found in the Kazoo tutorial chapters.</p>

<h3>
<a name="execution-engines" class="anchor" href="#execution-engines"><span class="octicon octicon-link"></span></a>Execution Engines</h3>

<p>Once you have generated your code you may want to run it.  RLTK provides bindings to both the LLVM interpreter and JIT compiler to help you do just that.  Creating a JIT compiler is pretty simple.</p>

<div class="highlight highlight-Ruby"><pre><span class="n">mod</span> <span class="o">=</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">Module</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">'my module'</span><span class="p">)</span>
<span class="n">jit</span> <span class="o">=</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">JITCompiler</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>

<span class="n">mod</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'add'</span><span class="p">,</span> <span class="ss">RLTK</span><span class="p">:</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="o">[</span><span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="p">,</span> <span class="no">RLTK</span><span class="o">::</span><span class="no">CG</span><span class="o">::</span><span class="no">NativeIntType</span><span class="o">]</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'entry'</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">fun</span><span class="o">|</span>
    <span class="n">ret</span> <span class="n">add</span><span class="p">(</span><span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="n">fun</span><span class="o">.</span><span class="n">params</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>Now you can run your 'add' function like this:</p>

<div class="highlight highlight-Ruby"><pre><span class="n">jit</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

<p>The result will be a {RLTK::CG::GenericValue} object, and you will want to use its {RLTK::CG::GenericValue#to_i #to_i} and {RLTK::CG::GenericValue#to_f #to_f} methods to get the Ruby value result.</p>

<h2>
<a name="tutorial" class="anchor" href="#tutorial"><span class="octicon octicon-link"></span></a>Tutorial</h2>

<p>What follows is an in-depth example of how to use the Ruby Language Toolkit.  This tutorial will show you how to use RLTK to build a lexer, parser, AST nodes, and compiler to create a toy language called Kazoo. The tutorial is based on the LLVM <a href="http://llvm.org/docs/tutorial/">Kaleidoscope</a> tutorial, but has been modified to:</p>

<ul>
<li>a) be done in Ruby</li>
<li>2) use a lexer and parser generator and</li>
<li>III) use a language that I call Kazoo, which is really just a cleaned up and simplified version of the Kaleidoscope language used in the LLVM tutorial (as opposed to the <a href="http://en.wikipedia.org/wiki/Kaleidoscope_%28programming_language%29">Kaleidoscope language</a> from the 90′s).</li>
</ul><p>The Kazoo toy language is a procedural language that allows you to define functions, use conditionals, and perform basic mathematical operations.  Over the course of the tutorial we’ll extend Kazoo to support the if/then/else construct, for loops, JIT compilation, and a simple command line interface to the JIT.</p>

<p>Because we want to keep things simple the only datatype in Kazoo is a 64-bit floating point type (a C double or a Ruby float).  As such, all values are implicitly double precision and the language doesn’t require type declarations.  This gives the language a very nice and simple syntax.  For example, the following example computes Fibonacci numbers:</p>

<pre><code>def fib(x)
  if x &lt; 3 then
    1
  else
    fib(x-1) + fib(x-2)
</code></pre>

<p>The tutorial is organized as follows:</p>

<ul>
<li><a href="https://github.com/chriswailes/RLTK/blob/master/examples/kazoo/chapter%201/Chapter1.md">Chapter 1: The Lexer</a></li>
<li><a href="https://github.com/chriswailes/RLTK/blob/master/examples/kazoo/chapter%202/Chapter2.md">Chapter 2: The AST Nodes</a></li>
<li><a href="https://github.com/chriswailes/RLTK/blob/master/examples/kazoo/chapter%203/Chapter3.md">Chapter 3: The Parser</a></li>
<li><a href="https://github.com/chriswailes/RLTK/blob/master/examples/kazoo/chapter%204/Chapter4.md">Chapter 4: AST Translation</a></li>
<li><a href="https://github.com/chriswailes/RLTK/blob/master/examples/kazoo/chapter%205/Chapter5.md">Chapter 5: JIT Compilation</a></li>
<li><a href="https://github.com/chriswailes/RLTK/blob/master/examples/kazoo/chapter%206/Chapter6.md">Chapter 6: Adding Control Flow</a></li>
<li><a href="https://github.com/chriswailes/RLTK/blob/master/examples/kazoo/chapter%207/Chapter7.md">Chapter 7: Playtime</a></li>
<li><a href="https://github.com/chriswailes/RLTK/blob/master/examples/kazoo/chapter%208/Chapter8.md">Chapter 8: Mutable Variables</a></li>
</ul><p>Before starting this tutorial you should know about regular expressions, the basic ideas behind lexing and parsing, and be able to read context-free grammar (CFG) definitions.  By the end of this tutorial we will have written 372 lines of source code and have a JIT compiler for a Turing complete language.</p>

<h2>
<a name="provided-lexers-and-parsers" class="anchor" href="#provided-lexers-and-parsers"><span class="octicon octicon-link"></span></a>Provided Lexers and Parsers</h2>

<p>The following lexer and parser classes are included as part of RLTK:</p>

<ul>
<li>{RLTK::Lexers::Calculator}</li>
<li>{RLTK::Lexers::EBNF}</li>
<li>{RLTK::Parsers::PrefixCalc}</li>
<li>{RLTK::Parsers::InfixCalc}</li>
<li>{RLTK::Parsers::PostfixCalc}</li>
</ul><h2>
<a name="contributing" class="anchor" href="#contributing"><span class="octicon octicon-link"></span></a>Contributing</h2>

<p>If you are interested in contributing to RLTK there are many aspects of the library that you can work on.  A detailed TODO list can be found <a href="https://github.com/chriswailes/RLTK/blob/master/TODO.md">here</a>.  If you are looking for smaller units of work feel free to:</p>

<ul>
<li>Help provide unit tests.  Not all of RLTK is tested as well as it could be.  Specifically, more tests for the RLTK::CFG and RLTK::Parser classes would be appreciated.</li>
<li>Write lexers or parsers that you think others might want to use.  Possibilities include HTML, JSON/YAML, Javascript, and Ruby.</li>
<li>Extend the RLTK::CFG class with additional functionality.</li>
</ul><p>Lastly, I love hearing back from users.  If you find any part of the documentation unclear or incomplete let me know.  It is also helpful to me to know how people are using the library, so if you are using RLTK in your project send me an email.  This lets me know what features are being used and where I should focus my development efforts.</p>

<h2>
<a name="news" class="anchor" href="#news"><span class="octicon octicon-link"></span></a>News</h2>

<p>Aaaaand we're back.  Development of RLTK has been on hold for a while as I worked on other projects.  If you want to see what I've been up to, you can check out <a href="http://llvm.org/clang">Clang's</a> new <code>-Wconsumed</code> flag and the <a href="http://github.com/chriswailes/filigree">Filigree</a> gem.</p>

<p>The next version of RLTK is going to be updated to require Ruby 2.0 as well as LLVM 3.4.  Previous versions of RLTK required my LLVM-ECB libarary to expose extra LLVM features through the C bindings; this is no longer necessary as this functionality has been moved into LLVM proper.  If anyone has any requests for new or improved features for RLTK version 3.0, let me know.</p>
        </section>

        <footer>
          The Ruby Language Toolkit is maintained by <a href="https://github.com/chriswailes">chriswailes</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>